# Пример изображений minilibX

Это простой пример программы, созданный для 42 студентов, переходящих в графическую ветвь. Ее цель - помочь студентам понять, как изображения работают в графической библиотеке `minilibX`.


## 1) В чем суть ?

Если вы внимательно прочли документацию о `minilibX` то вы могли увидеть увидели, что  можете печатать пиксель на экране благодаря функции `mlx_put_pixel`. Но для лучше производительности мы будем использовать еще и другие функции. Подумайте об этом так: зачем вам использовать сотни маленьких функций printf, если вы действительно можете вызвать их один раз с большим вводом. Печать пикселей - то же самое.

Решение проблемы с отображением изображения состоит в том, чтобы «распечатать» все пиксели в памяти, а затем сразу на экране. И в этом цель использования изображений: они хранят в памяти ваши пиксели.

Использование изображений не является обязательным для проекта `FdF` (но вы можете быть довольно медленными на таких картах, как `mars`), но они станут критически важными для проекта `Fract'ol`, поскольку в нём вам придется выполнять отображение в реальном времени, что требует их использования.


## 2) Как это работает ?

На самом деле изображения `minilibX` являются просто указателями на строку типа `char`. Все очень просто: 1 Изображение = указатель типа char.  

Каждый пиксель вашего изображения представлен 4 символами. Данные каждой части пикселя помещаеются один за другим. Изображение представляет собой строку из множества наборов символов(по 4 шт.), в котором каждый набор символов содержит данные о каком то одном пикселе. Все эти наборы с данными о каждом из пикселей будут говорить нам о том каким образом их отображать на экране начиная с левого верхнего пикселя (координаты`(0;0)`), затем переходит в право, к следующему пикселю, а затем следующий ряд пикселей и т.д.   

Вот пример с разрешением 800x600 : Допустим у вас есть область на 480 000 пикселей (`800x600` = `480 000`), значит эта область будет представленна `1 920 000` символов (`480 000`x`4` = `1 920 000`) . т.е. вы получите указатель на строку типа `char`, длина которого составляет `1 920 000` символов.  


Как тогда найти нужный пиксель? Просто! Нужно начать поиск с первого пикселя, который находится в верхнем левом углу и координаты которого равны `(0; 0)`.  

Теперь представим, что вы хотите изменить цвет 6-го пикселя, то есть того, который имеет координаты `(5; 0)`, для этого нам нужно сместиться на 5 пикселей вправо: `0 + 4 * 5 = 20`.  Где `20` - позиция символа, с которого начинается набор симвлов представляющий 6 пиксель(остальные позиции в строке -` 20, 21, 22, 23`).  

> ** Примечание **: по соглашению координаты всегда будут записываться как `(x, y)`, где `x` - `Абсцисса`, а `y` - `Ордината`. [[wiki]](https://tehtab.ru/Guide/GuideMathematics/DiagramsConstruction/AbscissaAndOrdinate/)


Как теперь перейти на ось `y`? На самом деле это действительно просто: нам просто нужно использовать следующую формулу: `X позиция + 4 * Размер линии * Y позиция`.  
В качестве примера возьмем пиксель `(0; 2)` для размера окна `800x600`:  
Используем формулу `(0 + 4 * 800 * 2)` и получим  `6400` - позицию символа по оси `y`. Значит пиксель `(0; 2)` будет описываться символами` 6400, 6401, 6402, 6403` на нашем указателе на строку типа `char`.  

Почему 4 символа на один пиксель?  Все просто! 3 первых символа представляют собой цвет пикселя через значения **RGB** от `0` до `255`.
4-й пиксель - это альфа цвет, который говорит о прозрачности отображения выбранного пикселя, но мы не будем здесь об этом говорить, поэтому просто игнорируйте его.  

Время для другого примера : представим, что мы хотим окрасить пиксель из предыдущего примера в зеленый цвет. Мы знаем, что пиксель представлен как набор из нескольких диодов отбражающий каждый из которых отображает  только один цвевт в определенной насыщенности (**КРАСНЫЙ**, **ЗЕЛЕНЫЙ**, **СИНИЙ**, **АЛЬФА**), поэтому в предыдущем примере символы `6400, 6402, 6403` будут равну нулю, а символ` 6401` будет равен `255`. У нас получится что вот такое `0, 255, 0, 0`. 


## Как это использовать ?

Это немного раздражает при настройке, но после этого вы сможете легко повторно использовать его во всех своих графических проектах.

### Шаг 1 : Создадим изображение :

Create an image with its dedicated function :

`image_pointer = mlx_new_image(mlx_pointer, width, height);`
Be sure to store the return value of this function you will need later.

### Шаг 2 : получим указатель типа `char` на изображение

``my_image_data =  mlx_get_data_addr(image_pointer, &bpp, &size_line, &endian);``

Просто чтобы вы знали, переменные, отправленные здесь как адрес (`&bpp`,` &size_line` и `&endian`), представляютсобой:
- `&bpp` : количество бит на пиксель.
- `&size_line` : размер строки умноженый на 4.
- `&endian` : Порядок байтов [wiki_en](https://en.wikipedia.org/wiki/Endianness),[wiki_ru](https://ru.wikipedia.org/wiki/%D0%9F%D0%BE%D1%80%D1%8F%D0%B4%D0%BE%D0%BA_%D0%B1%D0%B0%D0%B9%D1%82%D0%BE%D0%B2).

Поскольку вы передаете здесь адрес своих переменных, **вам не нужно их инициализировать, функция сделает это за вас**. Если у вас возникли проблемы с пониманием использования этих переменных, ничего страшного, они, вероятно, вам вообще не понадобятся, но вам все равно нужно объявить их, поскольку они являются частью параметров функции `mlx_get_data_addr`.

Вот пример возможных возвращаемых значений:

```c
int     bpp;
int     size_line;
int     endian;
void    *mlx_ptr = mlx_init();
void    *img_ptr = mlx_new_image(mlx_ptr, 800, 600); // 800 = ширина ; 600 = высота
char    *img_data =  mlx_get_data_addr(img_ptr, &bpp, &size_line, &endian);
```
В этом примере мы имеем:
 - `bpp` = `32`, потому что пиксель закодирован `4 символами`, каждый из которых имеет значение `8 бит`, что дает нам 32.
 - `size_line` = `3200`. По тому что `800`*`4`, где `800` количество пикселей на одной строки равно, а 4 это размер одного закодированого пикселя(4 символа)
 - `endian` = `0` или `1`, в зависимости от архитектуры компьютера, который вы используете (более подробная информация по ссылке выше).

### Шаг 3 : Заполните изображение

Все, что вам нужно сделать, это использовать приведенную выше формулу (`X позиция * 4 + 4 * Размер линии * Y позиция`), чтобы вычислить положение пикселя, который вы хотите на указателе char, а затем изменить 3 первых символа в соответствии с цвет, который вы хотите получить.

### Шаг 4 : Показать изображение

Просто выполните: `mlx_put_image_to_window(mlx_ptr, win_ptr, img_ptr, 0, 0);`

В этом примере мы имеем: :
- `mlx_ptr` указатель, возвращаемый функцией `mlx_init`.
- `win_ptr` указатель на ваше окно `minilibX`.
- `img_ptr` указатель на ваше изображение `minilibX`.
- Первый `0` - это позиция X вашего изображения в окне, второй `0` - это позиция Y.

---

## Как обновить экран и получить анимированные изображения?

Это действительно просто:

Просто создайте цикл рендеринга, в котором вы измените цвет пикселей вашего изображения с помощью указателя символа, а в конце цикла просто вызовите `mlx_put_image_to_window`.
Если у вас возникли проблемы, попробуйте вызвать `mlx_destroy_image` перед рендерингом нового изображения.

---

### Вот и все для этого небольшого урока, надеюсь, вам понравилось. Если вы обнаружите какую-либо опечатку или неясную / неточную часть, не стесняйтесь открывать проблему или запрос на перенос! :).

> Autor  by [`keuhdall`](https://github.com/keuhdall/) 
> 
> Edit and translate [`evgenkarlson`](https://github.com/evgenkarlson)
